[
  {
    "id" : "ca3c4ed4-aa65-474c-b4c1-111683c5c3a7",
    "prId" : 2014,
    "comments" : [
      {
        "id" : "710021f5-5950-4b45-aec2-0525be987e8e",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : "Tomasz Godzik",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Maybe we could change it to :\r\n`@volatile private var repository: Option[FileTreeRepository[HashCode]] = None`\r\n?",
        "createdAt" : "2020-08-21T10:39:23Z",
        "updatedAt" : "2020-08-22T03:26:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : "Tomasz Godzik",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "042c8ef7-0751-43f6-bb12-e2f8055ca532",
        "parentId" : "710021f5-5950-4b45-aec2-0525be987e8e",
        "author" : {
          "login" : "eatkins",
          "name" : "Ethan Atkins",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/2658825?u=8ff05fe0cc4369d7c79d2521ef29f314e11445c2&v=4"
        },
        "body" : "This is obviously a coding preference thing but I prefer using `AtomicReference` to the `var foo: Option[X] = None` pattern. I know that using null is often considered an anti-pattern in scala but I find that atomic references work really nicely. They force you to think about the state of the variable more than a var does because you can't simply dereference it like a var, you have to call `get` on it. This makes me think more about the control flow that leads to the call to `get` and what state I expect the variable to be in which I find helpful for mutable references. Of course it could be `AtomicReference[Option[FileTreeRepository[HashCode]]]` to avoid null handling but I like avoiding unnecessary boxing where possible.\r\n\r\nThat being said, this is just my personal stylistic preference and isn't important to this particular change set so if you would feel more comfortable with a `var`, I'll make that change.",
        "createdAt" : "2020-08-21T16:07:11Z",
        "updatedAt" : "2020-08-22T03:26:11Z",
        "lastEditedBy" : {
          "login" : "eatkins",
          "name" : "Ethan Atkins",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/2658825?u=8ff05fe0cc4369d7c79d2521ef29f314e11445c2&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5f70cb9c-ccc9-4238-9b6a-55c72c786658",
        "parentId" : "710021f5-5950-4b45-aec2-0525be987e8e",
        "author" : {
          "login" : "tgodzik",
          "name" : "Tomasz Godzik",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Both are really not ideal. We can leave as is, thanks!",
        "createdAt" : "2020-08-21T16:46:21Z",
        "updatedAt" : "2020-08-22T03:26:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : "Tomasz Godzik",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "13192ebb3ddfb265aceb4225904caf6a57ae07e0",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +77,81 @@  override def cancel(): Unit = {\n    repository.getAndSet(null) match {\n      case null =>\n      case r => r.close()\n    }"
  },
  {
    "id" : "8a063fd6-8b08-4363-982f-f874f356b805",
    "prId" : 1629,
    "comments" : [
      {
        "id" : "d05b6368-473c-4595-8b3d-d4567ef4f701",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : "Tomasz Godzik",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Could you add a comment on why you need to sort and reverse it? It took me a while to realize what's going on.",
        "createdAt" : "2020-04-16T14:06:49Z",
        "updatedAt" : "2020-04-17T10:03:37Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : "Tomasz Godzik",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "366195c4-46a1-4858-9f9b-e75744d22a0c",
        "parentId" : "d05b6368-473c-4595-8b3d-d4567ef4f701",
        "author" : {
          "login" : "mlachkar",
          "name" : "Meriam Lachkar",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "body" : "you're right. In fact we need to delete all children before parent paths.",
        "createdAt" : "2020-04-16T14:10:07Z",
        "updatedAt" : "2020-04-17T10:03:37Z",
        "lastEditedBy" : {
          "login" : "mlachkar",
          "name" : "Meriam Lachkar",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "11a3ce5f2d61d4805920381b556695ad432792e5",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +99,103 @@    startWatching(new ju.ArrayList(sourceDirectoriesToWatch))\n    // reverse sorting here is necessary to delete parent paths at the end\n    createdSourceDirectories.asScala.sortBy(_.toNIO).reverse.foreach { dir =>\n      if (dir.isEmptyDirectory) {\n        dir.delete()"
  },
  {
    "id" : "15bf35d0-ac8f-4bd4-90ff-98aedf9690e5",
    "prId" : 1435,
    "comments" : [
      {
        "id" : "2c1cae7e-1709-4403-89b6-cf5a118b506b",
        "parentId" : null,
        "author" : {
          "login" : "kpbochenek",
          "name" : "Krzysiek Bochenek",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "we could add a comment why it has dedicated branch that is doing the same logic.",
        "createdAt" : "2020-02-17T13:01:21Z",
        "updatedAt" : "2020-02-17T16:18:06Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : "Krzysiek Bochenek",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3cc301f6-4889-4036-80c9-3644a9db37a8",
        "parentId" : "2c1cae7e-1709-4403-89b6-cf5a118b506b",
        "author" : {
          "login" : "tgodzik",
          "name" : "Tomasz Godzik",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "added",
        "createdAt" : "2020-02-17T14:48:30Z",
        "updatedAt" : "2020-02-17T16:18:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : "Tomasz Godzik",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "fb025d5358f8296b853bbb7ede33b89e75356b35",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +130,134 @@    override def onEvent(event: DirectoryChangeEvent): Unit = {\n      // in non-MacOS systems the path will be null\n      if (event.eventType() == EventType.OVERFLOW) {\n        didChangeWatchedFiles(event)\n      } else if (!Files.isDirectory(event.path())) {"
  },
  {
    "id" : "b66bd711-40f8-41f7-b928-6a42d011fd10",
    "prId" : 857,
    "comments" : [
      {
        "id" : "84f9ae73-f485-4620-a30e-dcd66b292914",
        "parentId" : null,
        "author" : {
          "login" : "mzarnowski",
          "name" : "Marek Żarnowski",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?v=4"
        },
        "body" : "please, add a comment that we create those paths just to get a notification they don't exist",
        "createdAt" : "2019-08-08T06:56:56Z",
        "updatedAt" : "2019-08-08T16:25:02Z",
        "lastEditedBy" : {
          "login" : "mzarnowski",
          "name" : "Marek Żarnowski",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "21a08d72-8415-4f94-a69a-5527119682ce",
        "parentId" : "84f9ae73-f485-4620-a30e-dcd66b292914",
        "author" : {
          "login" : "tgodzik",
          "name" : "Tomasz Godzik",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "added",
        "createdAt" : "2019-08-08T12:31:23Z",
        "updatedAt" : "2019-08-08T16:25:02Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : "Tomasz Godzik",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0dd3eede29c603619dd79001b736615bb5743729",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +67,71 @@    val createdSourceDirectories = new util.ArrayList[AbsolutePath]()\n    def watch(path: AbsolutePath, isSource: Boolean): Unit = {\n      if (!path.isDirectory && !path.isFile) {\n        val pathToCreate = if (path.isScalaOrJava) {\n          AbsolutePath(path.toNIO.getParent())"
  }
]